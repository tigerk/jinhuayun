### synchronized、volatile区别、synchronized锁粒度、原子性与可见性

------

Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块(**synchronized**) 和 **volatile** 关键字机制。

### 先说volatile

用volatile修饰的变量，有两个特点：

* 内存可见性
* 有序性，禁止指令重排



- 什么是内存可见性？

数据都是保存在内存中的吗？答案：不是的

数据在内存中存在，但是当用的时候会加载到cpu寄存器里，内存和寄存器是两个地方，从而有了内存可见性和寄存器可见性。



那这两个怎么样呢？



* 很多时候，数据从内存地址读取到寄存器里面，后面的计算过程中CPU就一直使用寄存器里面的值，即是内存地址上的值发生变化，CPU也不知道，CPU此时就是井底之蛙，而变量此时可以称为：寄存器可见性。
* 但是当变量被volatile修饰之后，CPU就不再偷懒，只要用到数据，它都会越过寄存器，直接从内存中读取，然后再在计算器中计算，最后返回给内存，这个时候变量就不在寄存器里面停留，就当寄存器不存在一样，这就称为内存可见性。



看下面的例子：

使用 busy 来防止thread执行，busy也没有使用锁来保护。

```java
while (busy) {
	/* do something else */
}
```

其他thread变更了busy的状态，但是thread仍然会继续执行

```java
busy = 0;
```

由于thread频繁访问，编译器会将busy放在寄存器中来优化，然后从寄存器读取而不读取内存中的busy值。 测试线程永远不会看到busy更新，而另一个线程只会更改内存中busy的值，从而导致死锁。 将busy标志声明为volatile会强制在每次测试之前读取其值。



- 什么是禁止指令重排？

现在的CPU一般采用流水线来执行指令。一个指令的执行被分成：取指、译码、访存、执行、写回等若干个阶段。多条指令可以同时存在于流水线中，同时被执行。

指令流水线并不是串行的，并不会因为一个耗时很长的指令在"执行"阶段呆很长时间，而导致后续的指令都卡在"执行"之前的阶段上。

相反，流水线是并行的，多个指令可以同时处于同一个阶段，只要CPU内部相应的处理部件未被占满即可。比如说CPU有一个加法器和一个除法器，那么一条加法指令和一条除法指令就可能同时处于"执行"阶段，而两条加法指令在"执行"阶段就只能串行工作。相比于串行方式，流水线像这样并行的工作，效率是非常高的。



看下面的例子：

```java
public class CPUDemo {
    static int mainmemory = 1;
    public static void main(String[] args) {
        int sum = mainmemory +1;
        int localmemory = 2;
    }
}
```

mainmemory变量是从主存中加载的，肯定不如localmemory赋值快，localmemory的赋值操作可是在寄存器中操作的，所以就发生了乱序：
int localmemory = 2;先执行完，然后再执行完int sum = mainmemory +1;



**那问题来了，volatile为什么不能保证原子性？**

以volatile int i = 10；i++；为例分析：

i++实际为load、Increment、store三个操作。

线程1执行increment操作，线程2在load时会同步到increment结果，所以会出现线程安全问题。



### synchronized

Synchronized保证了原子性，可见性与有序性。

它的工作时对同步的代码块加锁，使得每次只有一个线程进入代码块，从而保证线程安全。

synchronized反应到字节码层面就是monitorenter与monitorexit.

synchronized锁粒度、模拟死锁场景、原子性与可见性

>**注意**：虽然synchonized关键字看起来是万能的，能保证线程安全性，但是越万能的控制往往越伴随着越大的性能影响。

Synchronized的锁粒度来说：

1. 实例方法上，被修饰的方法称为同步方法，其作用的范围是整个方法，
2. 作用的对象是调用这个方法的对象；
3. 静态方法上，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；

