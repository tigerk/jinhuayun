### 线程池的原理，为什么创建多线程

先来举个栗子，每个线程消耗25M内存，如果有10个请求，建立10个线程，消耗250M内存，看着没啥问题，

但是来10000个请求，需要建立1万个线程，那1万个线程就消耗会250000M，也就是250G内存，

这大大超出了服务器的容量，而且大部分时间并不会需要建立1万个线程，会造成大量的内存浪费，频繁创建和销毁线程也会带来开销。



#### 合理利用线程池能够带来三个好处：

* 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
* 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
* 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。



demo：

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 线程池demo
 */
public class MyPool {

    public static void main(String[] args) {
        /**
         * 在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：
         * Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
         * Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
         * Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
         */
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(5));

        for (int i = 1; i <= 15; i++) {
            MyThread myTask = new MyThread(i + "");
            executor.execute(myTask);
            System.out.println("线程池中线程数目：" + executor.getPoolSize() + "，队列中等待执行的任务数目：" + executor.getQueue().size() + "，已执行完别的任务数目：" + executor.getCompletedTaskCount());
        }
        executor.shutdown();
    }
}

class MyThread implements Runnable {
    private String threadName;

    public MyThread(String name) {
        threadName = name;
    }

    @Override
    public void run() {
        System.out.println("正在执行任务中，名称：" + threadName);
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("task " + threadName + "执行完毕");
    }
}
```

